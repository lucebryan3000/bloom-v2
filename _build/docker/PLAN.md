## Docker-First OmniForge Implementation Plan

Target: Refactor OmniForge so all workflows run inside the `app` container by default, with secrets in a gitignored env file and Docker required for every profile. Sequence is ordered to stay incremental and recoverable.

---

### Phase 0 — Prep & Decisions (already agreed)
- Execution model: `omni.sh` re-execs itself into the `app` container when `DOCKER_EXEC_MODE=container` (default).
- Secrets model: `.omni.secrets.env` (gitignored) is generated by OmniForge and injected into compose via `env_file` / `--env-file`.

---

### Phase 1 — Docker requirement & re-exec shim
**Objective:** Make Docker mandatory and add a single helper for compose/exec.

- Add config defaults in `omni.settings.sh`: `DOCKER_REQUIRED`, `DOCKER_EXEC_MODE`, `DOCKER_COMPOSE_FILE`, `APP_SERVICE_NAME`.
- Extend `lib/validation.sh` with `require_docker` (checks docker daemon + compose plugin/binary) and invoke it in preflight.
- Add docker helpers (new `lib/docker.sh` or inside `lib/common.sh`): `omni_docker_compose`, `omni_docker_exec_app`, `omni_docker_run_app`.
- In `omni.sh`: if `DOCKER_REQUIRED && DOCKER_EXEC_MODE=container && !INSIDE_OMNI_DOCKER`, ensure compose is usable, `up -d ${APP_SERVICE_NAME}`, and re-exec inside the container with `INSIDE_OMNI_DOCKER=1`.

**Prompt to Codex:** “Implement Phase 1 of `_build/docker/PLAN.md`: add Docker gating, helpers, and re-exec logic; no functional changes beyond that.”

---

### Phase 2 — App container & compose hardening
**Objective:** Ensure the `app` container can run OmniForge + pnpm and sits on the same network as services.

- Update `tech_stack/docker/dockerfile-multistage.sh` to emit a dev Dockerfile with Node ${NODE_VERSION}, pnpm installed, `WORKDIR /workspace`, and utilities (bash, git, jq, curl).
- Update `tech_stack/docker/docker-compose-pg.sh` so `app` builds from `Dockerfile.dev`, mounts `.:/workspace`, sets `working_dir: /workspace`, and shares `${APP_NAME}_network`. Keep `postgres` (and optional `redis`) on that network.
- Keep service autostart out of scripts for now; the re-exec wrapper will `up -d` the app (and optionally DB) before running phases.

**Prompt to Codex:** “Implement Phase 2 of `_build/docker/PLAN.md`: harden Dockerfile.dev and docker-compose.yml so `app` is runnable for OmniForge.”

---

### Phase 3 — Secrets layer (`.omni.secrets.env`)
**Objective:** Remove in-repo secrets and centralize generated secrets.

- Add `lib/secrets.sh` (loaded by `lib/common.sh`) with `OMNI_SECRETS_FILE=.omni.secrets.env`, `generate_secret()`, and `ensure_secret KEY [file]`.
- `.gitignore`: add `.omni.secrets.env`.
- Strip hardcoded secrets from `omni.config` (e.g., `DB_PASSWORD` value); keep non-sensitive defaults.
- Update Docker/DB/service scripts to call `ensure_secret` before templating compose fragments and to source values from env/`env_file` instead of inline literals (DB_PASSWORD, MINIO_ROOT_PASSWORD, MEILI_MASTER_KEY, GRAFANA_PASSWORD, AUTH_SECRET, etc.).
- Update compose generation to include `env_file: .omni.secrets.env` (or pass `--env-file`) for app/postgres/optional services.

**Prompt to Codex:** “Implement Phase 3 of `_build/docker/PLAN.md`: add secrets helper, gitignore entry, remove hardcoded secrets, and wire compose/env templates to `.omni.secrets.env`.”

---

### Phase 4 — Containerized installs & pnpm usage
**Objective:** Ensure OmniForge’s installs run inside the `app` container; avoid host `.tools` in container mode.

- `tech_stack/_lib/pkg-install.sh`: when `INSIDE_OMNI_DOCKER=1`, use container pnpm directly; only fall back to host behavior if `DOCKER_EXEC_MODE=host`.
- `lib/prereqs-local.sh`: if `INSIDE_OMNI_DOCKER=1`, skip installing `.tools` Node/pnpm and just assert the binaries exist (they’re baked into the image).
- `bin/omni` run path: in container mode, ensure `omni_docker_compose up -d app postgres` (and flag-based extras) before phases, then rely on container pnpm for installs.
- Keep host-mode as an escape hatch but not default.

**Prompt to Codex:** “Implement Phase 4 of `_build/docker/PLAN.md`: route installs through the app container and disable host `.tools` when inside Docker.”

---

### Phase 5 — Service gating + lifecycle commands
**Objective:** Make service enablement flag-driven and expose simple stack controls.

- `omni.profiles.sh`: add booleans for optional services (e.g., ENABLE_REDIS/MEILI/MINIO/OBSERVABILITY per profile).
- `omni.phases.sh` / phase harness: mark docker_required=true for all phases; conditionally include service setup scripts based on flags.
- `bin/omni` (or new `bin/stack` subcommands): expose `stack up/down/ps` wrappers calling `omni_docker_compose`.
- Ensure compose “up” includes optional services when their flags are true.

**Prompt to Codex:** “Implement Phase 5 of `_build/docker/PLAN.md`: wire profile flags for optional services and add stack lifecycle helpers.”

---

### Phase 6 — Documentation & migration
**Objective:** Document the new model and provide a migration note.

- Update `_build/omniforge/OMNIFORGE.md` and `docs/DEPENDENCY-ARCHITECTURE.md` to describe: Docker-first re-exec, `.omni.secrets.env`, containerized installs, and stack commands.
- Add an “Upgrading from host installs” note (remove old `.tools`, keep `.env.local` but secrets now in `.omni.secrets.env`).
- Verify `ignored-files` includes the secrets file (and any legacy `.tools` guidance).

**Prompt to Codex:** “Implement Phase 6 of `_build/docker/PLAN.md`: refresh docs and migration guidance for the Docker-first flow.”

---

### Guardrails / Do-once checks
- After Phase 2: `docker compose up -d app postgres` should allow `docker compose exec app bash` and `pnpm -v`.
- After Phase 3: `.omni.secrets.env` should exist post-run and compose should consume it (no secrets in repo).
- After Phase 4: Running `omni --dry-run` should execute inside the container (check `INSIDE_OMNI_DOCKER` in logs) and avoid writing `.tools`.
- Keep host-mode as a fallback but treat container mode as the default happy path.
