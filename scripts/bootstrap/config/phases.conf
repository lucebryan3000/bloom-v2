#!/usr/bin/env bash
# =============================================================================
# phases.conf - Phase definitions and script metadata
# =============================================================================
# Format: PHASE_ID:PHASE_NAME:SCRIPT_COUNT:DEPENDENCIES:DESCRIPTION
# Dependencies are comma-separated phase IDs that must complete first
# =============================================================================

# Phase definitions
# Each line defines a phase with its metadata
PHASES=(
    "foundation:Project Foundation:4::Initialize Next.js 15 project with TypeScript and directory structure"
    "docker:Docker Infrastructure:3:foundation:Multi-stage Dockerfile, docker-compose with PostgreSQL"
    "db:Database Layer:4:foundation:Drizzle ORM setup with PostgreSQL and pgvector"
    "env:Environment & Security:4:foundation:Environment validation, Zod schemas, rate limiting"
    "auth:Authentication:2:foundation,env:Auth.js v5 with Drizzle adapter and route handlers"
    "ai:AI Integration:3:foundation,db:Vercel AI SDK with Anthropic, prompts, chat scaffold"
    "state:State Management:2:foundation:Zustand stores with persistence and hydration"
    "jobs:Background Jobs:2:db:pg-boss job queue with worker templates"
    "observability:Observability:2:foundation:Pino structured logging with pino-pretty"
    "ui:UI Components:3:foundation:shadcn/ui, react-to-print, component structure"
    "testing:Testing Infrastructure:3:foundation:Vitest unit tests, Playwright E2E"
    "quality:Code Quality:3:foundation:ESLint, Prettier, Husky, lint-staged, TypeScript strict"
)

# Script mappings per phase
# Format: PHASE_ID -> array of script paths (relative to bootstrap dir)
declare -A PHASE_SCRIPTS
PHASE_SCRIPTS["foundation"]="
    foundation/init-nextjs.sh
    foundation/init-typescript.sh
    foundation/init-package-engines.sh
    foundation/init-directory-structure.sh
"
PHASE_SCRIPTS["docker"]="
    docker/dockerfile-multistage.sh
    docker/docker-compose-pg.sh
    docker/docker-pnpm-cache.sh
"
PHASE_SCRIPTS["db"]="
    db/drizzle-setup.sh
    db/drizzle-schema-base.sh
    db/drizzle-migrations.sh
    db/db-client-index.sh
"
PHASE_SCRIPTS["env"]="
    env/env-validation.sh
    env/zod-schemas-base.sh
    env/rate-limiter.sh
    env/server-action-template.sh
"
PHASE_SCRIPTS["auth"]="
    auth/authjs-setup.sh
    auth/auth-routes.sh
"
PHASE_SCRIPTS["ai"]="
    ai/vercel-ai-setup.sh
    ai/prompts-structure.sh
    ai/chat-feature-scaffold.sh
"
PHASE_SCRIPTS["state"]="
    state/zustand-setup.sh
    state/session-state-lib.sh
"
PHASE_SCRIPTS["jobs"]="
    jobs/pgboss-setup.sh
    jobs/job-worker-template.sh
"
PHASE_SCRIPTS["observability"]="
    observability/pino-logger.sh
    observability/pino-pretty-dev.sh
"
PHASE_SCRIPTS["ui"]="
    ui/shadcn-init.sh
    ui/react-to-print.sh
    ui/components-structure.sh
"
PHASE_SCRIPTS["testing"]="
    testing/vitest-setup.sh
    testing/playwright-setup.sh
    testing/test-directory.sh
"
PHASE_SCRIPTS["quality"]="
    quality/eslint-prettier.sh
    quality/husky-lintstaged.sh
    quality/ts-strict-mode.sh
"

# Phase order (execution sequence)
PHASE_ORDER=(
    "foundation"
    "docker"
    "db"
    "env"
    "auth"
    "ai"
    "state"
    "jobs"
    "observability"
    "ui"
    "testing"
    "quality"
)

# Feature flag to phase mapping
# Which feature flag controls which phase
declare -A PHASE_FEATURE_FLAGS
PHASE_FEATURE_FLAGS["auth"]="ENABLE_AUTHJS"
PHASE_FEATURE_FLAGS["ai"]="ENABLE_AI_SDK"
PHASE_FEATURE_FLAGS["state"]="ENABLE_ZUSTAND"
PHASE_FEATURE_FLAGS["jobs"]="ENABLE_PG_BOSS"
PHASE_FEATURE_FLAGS["ui"]="ENABLE_SHADCN"
PHASE_FEATURE_FLAGS["testing"]="ENABLE_TEST_INFRA"
PHASE_FEATURE_FLAGS["quality"]="ENABLE_CODE_QUALITY"

# =============================================================================
# Helper functions for phase management
# =============================================================================

# Get phase metadata by ID
# Usage: get_phase_info "foundation"
get_phase_info() {
    local phase_id="$1"
    for phase in "${PHASES[@]}"; do
        if [[ "${phase%%:*}" == "${phase_id}" ]]; then
            echo "${phase}"
            return 0
        fi
    done
    return 1
}

# Get phase name by ID
get_phase_name() {
    local info
    info=$(get_phase_info "$1") || return 1
    echo "${info}" | cut -d: -f2
}

# Get phase dependencies
get_phase_deps() {
    local info
    info=$(get_phase_info "$1") || return 1
    echo "${info}" | cut -d: -f4
}

# Get phase description
get_phase_description() {
    local info
    info=$(get_phase_info "$1") || return 1
    echo "${info}" | cut -d: -f5
}

# Get scripts for a phase
get_phase_scripts() {
    local phase_id="$1"
    echo "${PHASE_SCRIPTS[$phase_id]}" | tr -s '[:space:]' '\n' | grep -v '^$'
}

# Check if phase dependencies are met
check_phase_deps() {
    local phase_id="$1"
    local state_file="${2:-scripts/bootstrap/state/.bootstrap-state}"
    local deps
    deps=$(get_phase_deps "${phase_id}")

    [[ -z "${deps}" ]] && return 0

    IFS=',' read -ra dep_array <<< "${deps}"
    for dep in "${dep_array[@]}"; do
        if ! grep -q "^PHASE:${dep}:completed$" "${state_file}" 2>/dev/null; then
            echo "Missing dependency: ${dep}"
            return 1
        fi
    done
    return 0
}

# Check if phase is enabled via feature flag
is_phase_enabled() {
    local phase_id="$1"
    local flag_name="${PHASE_FEATURE_FLAGS[$phase_id]:-}"

    # Phases without flags are always enabled
    [[ -z "${flag_name}" ]] && return 0

    # Check the flag value
    local flag_value="${!flag_name:-true}"
    [[ "${flag_value}" == "true" ]]
}
