#!/usr/bin/env bash
set -euo pipefail

ROOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/../.." && pwd)"
cd "${ROOT_DIR}"

SCHEMA_FILE="prisma/schema.prisma"

if [[ ! -f "${SCHEMA_FILE}" ]]; then
  echo "ERROR: ${SCHEMA_FILE} not found. Are you in the Bloom repo root?"
  exit 1
fi

append_model_if_missing() {
  local model_name="$1"
  local marker="model ${model_name} "
  if grep -q "${marker}" "${SCHEMA_FILE}"; then
    echo "Model ${model_name} already present in ${SCHEMA_FILE}, skipping."
    return 0
  fi
  echo ">> Appending model ${model_name} to ${SCHEMA_FILE}"
  cat >> "${SCHEMA_FILE}" <<'EOF'

/// AUTO-ADDED BY _build-prompts/1_schema_and_migrate.sh
/// Core definition of who Melissa is for a given tenant / environment.
/// One record will usually be "Melissa v2" and marked as isDefault = true.
model MelissaPersona {
  id               String   @id @default(cuid())
  name             String
  slug             String   @unique
  description      String?

  baseTone         String
  explorationTone  String?
  synthesisTone    String?

  cognitionPrimary   String
  cognitionSecondary String?
  cognitionTertiary  String?

  curiosityModes   String[]

  explorationLevel Int      @default(50)
  structureLevel   Int      @default(50)

  behaviorConfig    Json?
  reportPreferences Json?

  isDefault        Boolean  @default(false)

  organizationId   String?
  organization     Organization? @relation(fields: [organizationId], references: [id])

  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt
}

EOF
}

append_chat_protocol_if_missing() {
  local marker="model ChatProtocol "
  if grep -q "${marker}" "${SCHEMA_FILE}"; then
    echo "Model ChatProtocol already present in ${SCHEMA_FILE}, skipping."
    return 0
  fi
  echo ">> Appending model ChatProtocol to ${SCHEMA_FILE}"
  cat >> "${SCHEMA_FILE}" <<'EOF'

/// Defines the behavioral rules and engine settings Melissa uses during a session.
/// This is the "OS" for how she asks questions, handles drift, clarifies, and progresses phases.
model ChatProtocol {
  id              String   @id @default(cuid())
  name            String
  slug            String   @unique
  description     String?

  phases          String[]

  oneQuestionMode Boolean   @default(true)
  maxQuestions    Int       @default(25)
  maxFollowups    Int       @default(3)
  allowQuestionMerging  Boolean @default(true)
  allowQuestionSkipping Boolean @default(true)

  driftSoftLimit  Int       @default(3)
  driftHardLimit  Int       @default(5)
  confusionTriggers    String[]
  clarificationStrategy String @default("rephrase_with_examples")

  complianceMode Boolean @default(false)
  strictPhases   Boolean @default(false)

  behaviorConfig  Json?
  isDefault       Boolean @default(false)

  organizationId  String?
  organization    Organization? @relation(fields: [organizationId], references: [id])

  playbookSources PlaybookSource[]

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
}

EOF
}

append_playbook_source_if_missing() {
  local marker="model PlaybookSource "
  if grep -q "${marker}" "${SCHEMA_FILE}"; then
    echo "Model PlaybookSource already present in ${SCHEMA_FILE}, skipping."
    return 0
  fi
  echo ">> Appending model PlaybookSource to ${SCHEMA_FILE}"
  cat >> "${SCHEMA_FILE}" <<'EOF'

/// Human-authored playbook definition in Markdown form.
/// This is the source-of-truth editing surface for a playbook.
model PlaybookSource {
  id          String   @id @default(cuid())

  name        String
  slug        String   @unique

  category    String
  objective   String?

  markdown    String
  description String?

  personaId   String?
  persona     MelissaPersona? @relation(fields: [personaId], references: [id])

  protocolId  String?
  protocol    ChatProtocol?   @relation(fields: [protocolId], references: [id])

  version     String   @default("1.0.0")
  status      String   @default("draft")
  isDefault   Boolean  @default(false)

  organizationId String?
  organization   Organization? @relation(fields: [organizationId], references: [id])

  compiledPlaybooks PlaybookCompiled[]

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

EOF
}

append_playbook_compiled_if_missing() {
  local marker="model PlaybookCompiled "
  if grep -q "${marker}" "${SCHEMA_FILE}"; then
    echo "Model PlaybookCompiled already present in ${SCHEMA_FILE}, skipping."
    return 0
  fi
  echo ">> Appending model PlaybookCompiled to ${SCHEMA_FILE}"
  cat >> "${SCHEMA_FILE}" <<'EOF'

/// Structured, runtime-ready representation of a playbook.
/// Generated by parsing/compiling a PlaybookSource (Markdown).
model PlaybookCompiled {
  id          String   @id @default(cuid())

  sourceId    String
  source      PlaybookSource @relation(fields: [sourceId], references: [id])

  name        String
  slug        String
  category    String
  objective   String?

  version     String   @default("1.0.0")
  status      String   @default("compiled_ok")
  isActive    Boolean  @default(false)

  personaId   String?
  persona     MelissaPersona? @relation(fields: [personaId], references: [id])

  protocolId  String?
  protocol    ChatProtocol?   @relation(fields: [protocolId], references: [id])

  phaseMap      Json
  questions     Json
  scoringModel  Json?
  reportSpec    Json?
  rulesOverrides Json?
  compileInfo   Json?

  compiledAt   DateTime @default(now())
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
}

EOF
}

echo "==> Updating Prisma schema with MelissaPersona, ChatProtocol, PlaybookSource, PlaybookCompiled (if missing)..."

append_model_if_missing "MelissaPersona"
append_chat_protocol_if_missing
append_playbook_source_if_missing
append_playbook_compiled_if_missing

# echo "==> Running npx prisma format"
# npx prisma format
echo "==> Skipping prisma format (cosmetic only, causes download errors in sandboxed environments)"

echo "==> Running npx prisma migrate dev --name add_melissa_playbook_architecture"
npx prisma migrate dev --name add_melissa_playbook_architecture

echo "==> Generating Prisma client with new models"
npx prisma generate

# Create a dedicated seed script for these models (does not touch existing seed.ts)
SEED_SCRIPT="prisma/seed-melissa-playbooks.cjs"

if [[ -f "${SEED_SCRIPT}" ]]; then
  echo "Seed script ${SEED_SCRIPT} already exists, skipping creation."
else
  echo ">> Creating ${SEED_SCRIPT}"
  cat > "${SEED_SCRIPT}" <<'EOF'
/* Seed script for Melissa persona, protocol, and example playbook sources/compiled.
 * Run with: node prisma/seed-melissa-playbooks.cjs
 */
const { PrismaClient } = require('@prisma/client');
const prisma = new PrismaClient();

async function main() {
  // Upsert default Melissa persona
  const persona = await prisma.melissaPersona.upsert({
    where: { slug: 'melissa_v2' },
    update: {},
    create: {
      name: 'Melissa.ai – Investigative Synthesist v2',
      slug: 'melissa_v2',
      description: 'Investigative Synthesist persona for Appmelia Bloom.',
      baseTone: 'warmly_analytical',
      explorationTone: 'curious_playful',
      synthesisTone: 'executive_crisp',
      cognitionPrimary: 'systems_thinking',
      cognitionSecondary: 'first_principles',
      cognitionTertiary: 'narrative_synthesizer',
      curiosityModes: ['evidence', 'pattern', 'assumption', 'empathic'],
      explorationLevel: 60,
      structureLevel: 55,
      behaviorConfig: {
        sideQuestSoftLimit: 3,
        sideQuestHardLimit: 5,
        clarificationExamples: true
      },
      reportPreferences: {
        execSummaryStyle: 'crisp',
        useBulletsInInsights: true
      },
      isDefault: true
    }
  });

  // Upsert default ChatProtocol
  const protocol = await prisma.chatProtocol.upsert({
    where: { slug: 'bloom_ifl_v1' },
    update: {},
    create: {
      name: 'Bloom IFL – One Question Engine',
      slug: 'bloom_ifl_v1',
      description: 'Primary Intelligent Facilitation Loop protocol for Melissa.ai sessions.',
      phases: [
        'greet_frame',
        'discover_probe',
        'validate_quantify',
        'synthesize_reflect',
        'advance_close'
      ],
      oneQuestionMode: true,
      maxQuestions: 25,
      maxFollowups: 3,
      allowQuestionMerging: true,
      allowQuestionSkipping: true,
      driftSoftLimit: 3,
      driftHardLimit: 5,
      confusionTriggers: [
        "I don't know",
        "not sure",
        "what do you mean",
        "help me understand"
      ],
      clarificationStrategy: 'rephrase_with_examples',
      complianceMode: false,
      strictPhases: false,
      behaviorConfig: {
        allowSideQuests: true,
        sideQuestSoftLimit: 3,
        sideQuestHardLimit: 5
      },
      isDefault: true
    }
  });

  // Example PlaybookSource
  const source = await prisma.playbookSource.upsert({
    where: { slug: 'bottleneck_throughput_v1' },
    update: {},
    create: {
      name: 'Enterprise Bottleneck & Throughput Accelerator',
      slug: 'bottleneck_throughput_v1',
      category: 'Throughput',
      objective: 'Identify the top 1–3 bottlenecks in a critical workflow and estimate capacity gains.',
      markdown: `
# Playbook: Enterprise Bottleneck & Throughput Accelerator
slug: bottleneck_throughput_v1
category: Throughput
objective: Identify the top 1–3 bottlenecks in a critical workflow and estimate capacity gains.
protocol: bloom_ifl_v1
persona: melissa_v2

## Phases
- greet_frame
- discover_probe
- validate_quantify
- synthesize_reflect
- advance_close

## Questions
- id: q_intro_scope
  phase: greet_frame
  type: free_text
  text: "In one sentence, which part of your operation feels most clogged right now?"

- id: q_where_clogs
  phase: discover_probe
  type: free_text
  text: "Where does work tend to pile up or wait for someone?"

- id: q_who_waits
  phase: discover_probe
  type: free_text
  text: "Who is everyone usually waiting on at that step?"

- id: q_frequency
  phase: validate_quantify
  type: scale
  text: "How often does this bottleneck cause delays in a typical week?"
  options: ["rarely", "1-2 times", "3-5 times", "daily", "multiple times per day"]

- id: q_impact_time
  phase: validate_quantify
  type: free_text
  text: "When it causes a delay, how many hours or days are typically lost?"

- id: q_if_half_better
  phase: synthesize_reflect
  type: free_text
  text: "If this bottleneck were 50% better, what would change first?"

- id: q_final_note
  phase: advance_close
  type: free_text
  text: "Is there anything else about this workflow leadership should understand before we summarize?"
`,
      description: 'Core throughput diagnostic for mid-market ops teams.',
      personaId: persona.id,
      protocolId: protocol.id,
      version: '1.0.0',
      status: 'draft',
      isDefault: true
    }
  });

  console.log('Seeded MelissaPersona, ChatProtocol, and example PlaybookSource:');
  console.log(' persona.slug  =', persona.slug);
  console.log(' protocol.slug =', protocol.slug);
  console.log(' source.slug   =', source.slug);
}

main()
  .catch((e) => {
    console.error('Error in seed-melissa-playbooks:', e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });
EOF
fi

echo "==> Running node prisma/seed-melissa-playbooks.cjs"
node "${SEED_SCRIPT}"

echo "Schema and seed step complete."
