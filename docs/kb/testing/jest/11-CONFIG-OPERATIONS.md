---
id: jest-11-config-operations
topic: jest
file_role: config
profile: full
difficulty_level: intermediate-to-advanced
kb_version: 3.1
prerequisites: [jest-01-fundamentals]
related_topics: [configuration, ci-cd, tooling]
embedding_keywords: [jest, configuration, jest-config, ci-cd, setup, teardown, coverage, debugging, watch-mode]
last_reviewed: 2025-11-14
---

# Jest Configuration & Operations Guide

**Version:** 3.1 (Bloom KB)
**Last Updated:** 2025-11-14
**Status:** Production
**Related:** [01-FUNDAMENTALS.md](01-FUNDAMENTALS.md), [06-API-TESTING.md](06-API-TESTING.md)

---

## Table of Contents

1. [Overview](#1-overview)
2. [Core Configuration](#2-core-configuration)
3. [Setup Files & Global Mocks](#3-setup-files--global-mocks)
4. [Next.js 16 Integration](#4-nextjs-16-integration)
5. [Coverage & Reporting](#5-coverage--reporting)
6. [CI/CD Integration](#6-cicd-integration)
7. [Development Workflow & Debugging](#7-development-workflow--debugging)

---

## 1. Overview

### 1.1 Purpose

This guide covers Jest configuration, setup, and operational practices for the Bloom project. It focuses on:

- **Configuration Management**: jest.config.cjs setup and customization
- **Setup Files**: Global test environment configuration
- **Next.js Integration**: Using next/jest preset for App Router
- **Coverage Tracking**: Thresholds, reports, and CI integration
- **Development Workflow**: Watch mode, debugging, and productivity tips

### 1.2 Configuration Files in Bloom

```
appmelia-bloom/
├── jest.config.cjs          # Main Jest configuration (Next.js 16 preset)
├── jest.setup.js            # Global test environment setup
├── package.json             # Test scripts and dependencies
├── .github/workflows/
│   └── ci-cd.yml           # GitHub Actions CI with Jest
├── __tests__/              # Test files (*.test.ts)
└── coverage/               # Generated coverage reports (gitignored)
```

### 1.3 Key Features

| Feature | Implementation | Status |
|---------|---------------|--------|
| **Next.js Integration** | `next/jest` preset with async config | ✅ Active |
| **TypeScript Support** | Path aliases (`@/`), type checking | ✅ Active |
| **Coverage Thresholds** | 80% lines/statements, 70% branches | ✅ Enforced |
| **Global Mocks** | Next.js router, navigation, Image | ✅ Active |
| **Prisma Mocking** | Database client mocked by default | ✅ Active |
| **E2E Exclusion** | Playwright tests excluded from Jest | ✅ Active |
| **CI/CD Integration** | GitHub Actions with coverage upload | ✅ Active |

---

## 2. Core Configuration

### 2.1 Bloom's jest.config.cjs

**Location:** `/home/user/bloom/jest.config.cjs`

```javascript
// Auto-generated by Claude per Appmelia Instruction Set v2
// Source: Appmelia [Bloom PRD v10 MVP v1.0](_build/PRD-Bloom/Bloom-PRD-v10-MVP-v1.0.md)

const nextJest = require('next/jest')

const createJestConfig = nextJest({
  // Provide the path to your Next.js app to load next.config.js and .env files
  dir: './',
})

// Add any custom config to be passed to Jest
const customJestConfig = {
  setupFilesAfterEnv: ['<rootDir>/jest.setup.js'],
  testEnvironment: 'jest-environment-jsdom',
  moduleNameMapper: {
    '^@/(.*)$': '<rootDir>/$1',
  },
  testPathIgnorePatterns: [
    '<rootDir>/.next/',
    '<rootDir>/node_modules/',
    '<rootDir>/tests/e2e/',        // Exclude Playwright E2E tests
    '<rootDir>/e2e/',              // Exclude old Playwright tests
    '<rootDir>/playwright/',       // Exclude Playwright specs
  ],
  collectCoverageFrom: [
    'app/**/*.{js,jsx,ts,tsx}',
    'lib/**/*.{js,jsx,ts,tsx}',
    'components/**/*.{js,jsx,ts,tsx}',
    '!**/*.d.ts',
    '!**/node_modules/**',
    '!**/.next/**',
    '!**/coverage/**',
    '!**/dist/**',
  ],
  coverageThreshold: {
    global: {
      branches: 70,
      functions: 70,
      lines: 80,
      statements: 80,
    },
  },
  // Only match .test.ts files (not .spec.ts which are Playwright tests)
  testMatch: [
    '**/__tests__/**/*.test.[jt]s?(x)',
    '**/?(*.)+test.[jt]s?(x)',
  ],
}

// createJestConfig is exported this way to ensure that next/jest can load the Next.js config which is async
module.exports = createJestConfig(customJestConfig)
```

### 2.2 Configuration Options Explained

#### 2.2.1 Next.js Preset

```javascript
const createJestConfig = nextJest({
  dir: './',
})
```

**What it does:**
- Loads `next.config.js` into Jest environment
- Automatically handles Next.js-specific transforms
- Configures SWC/Babel for TypeScript/JSX
- Sets up environment variables from `.env.local`

**Why use it:**
- Ensures parity between test and runtime environments
- Automatically handles Next.js 16 App Router conventions
- Simplifies configuration (no manual Babel setup)

#### 2.2.2 Test Environment

```javascript
testEnvironment: 'jest-environment-jsdom',
```

**Options:**
- `jest-environment-jsdom` - Browser-like environment (for React components)
- `jest-environment-node` - Node.js environment (for API routes, utilities)

**Bloom's Choice:** `jsdom` (default for Next.js apps)
- Provides `window`, `document`, `HTMLElement` APIs
- Required for `@testing-library/react`
- Suitable for 90% of tests in Bloom

**When to override:**
```typescript
// At the top of a specific test file (for API route tests)
/**
 * @jest-environment node
 */

import { GET } from '@/app/api/sessions/route'
```

#### 2.2.3 Module Name Mapper

```javascript
moduleNameMapper: {
  '^@/(.*)$': '<rootDir>/$1',
},
```

**Purpose:** Resolves TypeScript path aliases in tests

```typescript
// tsconfig.json defines:
{
  "paths": {
    "@/*": ["./*"]
  }
}

// Jest translates:
import { prisma } from '@/lib/db/client'
// to:
import { prisma } from '/home/user/bloom/lib/db/client'
```

**Common Patterns:**
```javascript
moduleNameMapper: {
  '^@/(.*)$': '<rootDir>/$1',                    // Path aliases
  '^@/components/(.*)$': '<rootDir>/components/$1', // Specific aliases
  '\\.(css|less|scss|sass)$': 'identity-obj-proxy', // CSS modules
  '\\.(jpg|jpeg|png|gif|svg)$': '<rootDir>/__mocks__/fileMock.js', // Static assets
}
```

#### 2.2.4 Test Path Ignore Patterns

```javascript
testPathIgnorePatterns: [
  '<rootDir>/.next/',
  '<rootDir>/node_modules/',
  '<rootDir>/tests/e2e/',        // Exclude Playwright E2E tests
  '<rootDir>/e2e/',              // Exclude old Playwright tests
  '<rootDir>/playwright/',       // Exclude Playwright specs
],
```

**Why this matters:**
- **Avoids Test Collisions**: Playwright uses `.spec.ts`, Jest uses `.test.ts`
- **Performance**: Excludes build artifacts and dependencies
- **Clarity**: Each test framework owns its directory

**Bloom's Test Organization:**
```
appmelia-bloom/
├── __tests__/              # Jest unit tests (*.test.ts)
│   ├── lib/
│   ├── components/
│   └── api/
├── tests/e2e/              # Playwright tests (*.spec.ts)
│   ├── specs/
│   └── fixtures/
└── .next/                  # Build artifacts (ignored)
```

#### 2.2.5 Coverage Collection

```javascript
collectCoverageFrom: [
  'app/**/*.{js,jsx,ts,tsx}',
  'lib/**/*.{js,jsx,ts,tsx}',
  'components/**/*.{js,jsx,ts,tsx}',
  '!**/*.d.ts',
  '!**/node_modules/**',
  '!**/.next/**',
  '!**/coverage/**',
  '!**/dist/**',
],
```

**Included:**
- `app/` - Next.js 16 App Router pages and API routes
- `lib/` - Business logic (ROI calculations, Melissa AI)
- `components/` - React components

**Excluded:**
- TypeScript declaration files (`*.d.ts`)
- Generated code (`.next/`, `dist/`)
- Test files themselves (implicitly excluded)

**To exclude specific files:**
```javascript
collectCoverageFrom: [
  'app/**/*.{js,jsx,ts,tsx}',
  '!app/api/webhooks/**',  // Exclude webhook handlers
  '!app/**/layout.tsx',    // Exclude Next.js layouts
]
```

#### 2.2.6 Test Match Patterns

```javascript
testMatch: [
  '**/__tests__/**/*.test.[jt]s?(x)',
  '**/?(*.)+test.[jt]s?(x)',
],
```

**Matches:**
- `__tests__/lib/roi/calculator.test.ts` ✅
- `components/ui/Button.test.tsx` ✅
- `app/api/sessions/route.test.ts` ✅

**Does NOT match:**
- `tests/e2e/workshop.spec.ts` ❌ (Playwright convention)
- `components/ui/Button.stories.tsx` ❌ (Storybook)
- `lib/utils.ts` ❌ (source file)

**Why `.test.ts` instead of `.spec.ts`:**
- Playwright uses `.spec.ts` (E2E tests)
- Jest uses `.test.ts` (unit/integration tests)
- Clear separation prevents accidental execution

### 2.3 Advanced Configuration Options

#### 2.3.1 Test Timeout

```javascript
// jest.config.cjs
module.exports = {
  testTimeout: 10000, // 10 seconds (default: 5000)
}
```

**When to increase:**
- Integration tests with real API calls
- Database seeding operations
- Heavy DOM rendering (complex components)

**Bloom's default:** 5000ms (sufficient for mocked tests)

#### 2.3.2 Setup Files

```javascript
setupFiles: ['<rootDir>/jest.env.js'],           // Before test framework
setupFilesAfterEnv: ['<rootDir>/jest.setup.js'], // After test framework
```

**Difference:**
- `setupFiles` - Runs before Jest loads (for env vars, polyfills)
- `setupFilesAfterEnv` - Runs after Jest loads (for matchers, mocks)

**Example `jest.env.js`:**
```javascript
// Set environment variables before tests
process.env.DATABASE_URL = 'file:./test.db'
process.env.NEXTAUTH_SECRET = 'test-secret'
```

#### 2.3.3 Module File Extensions

```javascript
moduleFileExtensions: ['ts', 'tsx', 'js', 'jsx', 'json'],
```

**Bloom's default (via next/jest):**
- Automatically includes TypeScript extensions
- No manual configuration needed

#### 2.3.4 Transform Ignore Patterns

```javascript
transformIgnorePatterns: [
  'node_modules/(?!(some-esm-package|another-esm-package)/)',
],
```

**When needed:**
- Some npm packages publish ES modules only
- Jest needs to transform them (default: ignores node_modules)

**Example:**
```javascript
// If using an ESM-only package like 'nanoid'
transformIgnorePatterns: [
  'node_modules/(?!(nanoid)/)',
],
```

#### 2.3.5 Globals

```javascript
globals: {
  'ts-jest': {
    tsconfig: {
      jsx: 'react',
    },
  },
},
```

**Bloom's approach:**
- Uses `next/jest` which handles TypeScript via SWC
- No manual `ts-jest` configuration needed
- SWC is faster than Babel/ts-jest

---

## 3. Setup Files & Global Mocks

### 3.1 Bloom's jest.setup.js

**Location:** `/home/user/bloom/jest.setup.js`

```javascript
// Auto-generated by Claude per Appmelia Instruction Set v2
// Source: Appmelia [Bloom PRD v10 MVP v1.0](_build/PRD-Bloom/Bloom-PRD-v10-MVP-v1.0.md)

import '@testing-library/jest-dom'

// Mock Next.js router (Pages Router - next/router)
jest.mock('next/router', () => ({
  useRouter() {
    return {
      route: '/',
      pathname: '/',
      query: {},
      asPath: '/',
      push: jest.fn(),
      replace: jest.fn(),
      reload: jest.fn(),
      back: jest.fn(),
      prefetch: jest.fn(),
      beforePopState: jest.fn(),
      events: {
        on: jest.fn(),
        off: jest.fn(),
        emit: jest.fn(),
      },
      isFallback: false,
    }
  },
}))

// Mock Next.js navigation (App Router - next/navigation)
jest.mock('next/navigation', () => ({
  useRouter() {
    return {
      push: jest.fn(),
      replace: jest.fn(),
      refresh: jest.fn(),
      back: jest.fn(),
      forward: jest.fn(),
      prefetch: jest.fn(),
    }
  },
  usePathname() {
    return '/'
  },
  useSearchParams() {
    return new URLSearchParams()
  },
  useParams() {
    return {}
  },
}))

// Mock Next.js Image component
jest.mock('next/image', () => ({
  __esModule: true,
  default: (props) => {
    // eslint-disable-next-line jsx-a11y/alt-text
    return <img {...props} />
  },
}))

// Suppress console errors in tests (optional)
global.console.error = jest.fn()
global.console.warn = jest.fn()

// Polyfill fetch for API integration tests
if (!global.fetch) {
  const nodeFetch = require('node-fetch')
  global.fetch = nodeFetch.default || nodeFetch
  global.Headers = nodeFetch.Headers
  global.Request = nodeFetch.Request
  global.Response = nodeFetch.Response
}

// Mock Prisma Client for tests that use database
jest.mock('@/lib/db/client', () => ({
  prisma: {
    session: {
      count: jest.fn().mockResolvedValue(0),
      findMany: jest.fn().mockResolvedValue([]),
      findUnique: jest.fn().mockResolvedValue(null),
      create: jest.fn(),
      update: jest.fn(),
      delete: jest.fn(),
    },
    $disconnect: jest.fn().mockResolvedValue(undefined),
  },
}))
```

### 3.2 Setup File Sections Explained

#### 3.2.1 Testing Library Matchers

```javascript
import '@testing-library/jest-dom'
```

**Provides custom matchers:**
```typescript
expect(element).toBeInTheDocument()
expect(element).toHaveTextContent('Hello')
expect(element).toBeVisible()
expect(input).toHaveValue('test')
```

**See:** [05-REACT-TESTING.md](05-REACT-TESTING.md#custom-matchers)

#### 3.2.2 Next.js Router Mocks (Pages Router)

```javascript
jest.mock('next/router', () => ({
  useRouter() {
    return {
      route: '/',
      pathname: '/',
      query: {},
      asPath: '/',
      push: jest.fn(),
      replace: jest.fn(),
      // ... all router methods
    }
  },
}))
```

**Why mock it:**
- `useRouter()` only works in Next.js runtime
- Tests would fail with "useRouter called outside of Next.js context"
- Allows testing components that use router without full Next.js setup

**Customizing per test:**
```typescript
import { useRouter } from 'next/router'

jest.mock('next/router')

test('navigates on button click', () => {
  const push = jest.fn()
  ;(useRouter as jest.Mock).mockReturnValue({ push })

  render(<MyComponent />)
  fireEvent.click(screen.getByRole('button'))

  expect(push).toHaveBeenCalledWith('/dashboard')
})
```

#### 3.2.3 Next.js Navigation Mocks (App Router)

```javascript
jest.mock('next/navigation', () => ({
  useRouter() {
    return {
      push: jest.fn(),
      replace: jest.fn(),
      refresh: jest.fn(),
      back: jest.fn(),
      forward: jest.fn(),
      prefetch: jest.fn(),
    }
  },
  usePathname() {
    return '/'
  },
  useSearchParams() {
    return new URLSearchParams()
  },
  useParams() {
    return {}
  },
}))
```

**Next.js 16 App Router hooks:**
- `useRouter()` - Client-side navigation
- `usePathname()` - Current path (replaces `router.pathname`)
- `useSearchParams()` - URL search params (replaces `router.query`)
- `useParams()` - Dynamic route params

**Example component using App Router:**
```typescript
// app/sessions/[id]/page.tsx
'use client'

import { useParams, useRouter } from 'next/navigation'

export function SessionPage() {
  const params = useParams()
  const router = useRouter()
  const sessionId = params.id as string

  return (
    <button onClick={() => router.push('/dashboard')}>
      Session {sessionId}
    </button>
  )
}
```

**Testing it:**
```typescript
import { useParams, useRouter } from 'next/navigation'
import { SessionPage } from '@/app/sessions/[id]/page'

jest.mock('next/navigation')

test('displays session ID from params', () => {
  ;(useParams as jest.Mock).mockReturnValue({ id: 'session-123' })
  render(<SessionPage />)
  expect(screen.getByText(/Session session-123/)).toBeInTheDocument()
})
```

#### 3.2.4 Next.js Image Mock

```javascript
jest.mock('next/image', () => ({
  __esModule: true,
  default: (props) => <img {...props} />
}))
```

**Why mock it:**
- `next/image` requires Next.js image optimization server
- Tests would fail trying to optimize images
- Mock renders a standard `<img>` tag instead

**Testing components with images:**
```typescript
import Image from 'next/image'

function Avatar({ src, alt }: { src: string; alt: string }) {
  return <Image src={src} alt={alt} width={40} height={40} />
}

test('renders avatar image', () => {
  render(<Avatar src="/avatar.png" alt="User avatar" />)
  const img = screen.getByAltText('User avatar')
  expect(img).toHaveAttribute('src', '/avatar.png')
})
```

#### 3.2.5 Console Suppression

```javascript
global.console.error = jest.fn()
global.console.warn = jest.fn()
```

**Purpose:**
- Reduces test output noise
- Hides expected errors (e.g., testing error boundaries)

**Toggle per test:**
```typescript
test('logs error on failure', () => {
  // Restore console temporarily
  const consoleError = jest.spyOn(console, 'error').mockImplementation()

  // Trigger error
  doSomethingThatLogs()

  expect(consoleError).toHaveBeenCalledWith(expect.stringContaining('error'))
  consoleError.mockRestore()
})
```

**Alternative (better for debugging):**
```javascript
// Only suppress React's "Warning:" messages
const originalError = console.error
global.console.error = (...args) => {
  if (args[0]?.includes('Warning:')) return
  originalError(...args)
}
```

#### 3.2.6 Fetch Polyfill

```javascript
if (!global.fetch) {
  const nodeFetch = require('node-fetch')
  global.fetch = nodeFetch.default || nodeFetch
  global.Headers = nodeFetch.Headers
  global.Request = nodeFetch.Request
  global.Response = nodeFetch.Response
}
```

**Why needed:**
- Node.js < 18 doesn't have native `fetch`
- API route tests need `fetch` for HTTP calls
- Bloom uses Node.js 20 (has native fetch), but this ensures compatibility

**Testing API routes with fetch:**
```typescript
test('GET /api/sessions returns sessions list', async () => {
  const response = await fetch('http://localhost:3001/api/sessions')
  const data = await response.json()
  expect(data).toHaveProperty('sessions')
})
```

#### 3.2.7 Prisma Client Mock

```javascript
jest.mock('@/lib/db/client', () => ({
  prisma: {
    session: {
      count: jest.fn().mockResolvedValue(0),
      findMany: jest.fn().mockResolvedValue([]),
      findUnique: jest.fn().mockResolvedValue(null),
      create: jest.fn(),
      update: jest.fn(),
      delete: jest.fn(),
    },
    $disconnect: jest.fn().mockResolvedValue(undefined),
  },
}))
```

**Why mock it:**
- Avoids real database connections in unit tests
- Makes tests fast and isolated
- Prevents test data pollution

**Customizing per test:**
```typescript
import { prisma } from '@/lib/db/client'

jest.mock('@/lib/db/client')

test('fetches session by ID', async () => {
  const mockSession = { id: '1', title: 'Test Session' }
  ;(prisma.session.findUnique as jest.Mock).mockResolvedValue(mockSession)

  const session = await getSessionById('1')

  expect(session).toEqual(mockSession)
  expect(prisma.session.findUnique).toHaveBeenCalledWith({
    where: { id: '1' }
  })
})
```

**For integration tests (use real database):**
```typescript
// Unmock Prisma for this test file
jest.unmock('@/lib/db/client')

import { prisma } from '@/lib/db/client'

afterAll(async () => {
  await prisma.$disconnect()
})
```

---

## 4. Next.js 16 Integration

### 4.1 The next/jest Preset

**What it provides:**
- Automatic TypeScript/JSX transformation via SWC
- Loads `next.config.js` into test environment
- Handles CSS/asset imports
- Configures module resolution
- Sets up environment variables

**Without next/jest (manual setup):**
```javascript
// Manual Jest config (DON'T DO THIS)
module.exports = {
  transform: {
    '^.+\\.(t|j)sx?$': ['@swc/jest', { /* config */ }],
  },
  moduleNameMapper: {
    '\\.(css|less|scss)$': 'identity-obj-proxy',
  },
  // ... 50+ more lines
}
```

**With next/jest (Bloom's approach):**
```javascript
const nextJest = require('next/jest')
const createJestConfig = nextJest({ dir: './' })
module.exports = createJestConfig({ /* minimal config */ })
```

### 4.2 Testing App Router Components

#### 4.2.1 Server Components

**Challenge:** Server Components can't be tested directly in Jest (jsdom)

**Solution:** Extract logic, test separately

```typescript
// app/sessions/page.tsx (Server Component)
import { getSessions } from '@/lib/sessions'

export default async function SessionsPage() {
  const sessions = await getSessions()
  return <SessionList sessions={sessions} />
}

// components/SessionList.tsx (Client Component)
'use client'

export function SessionList({ sessions }) {
  return (
    <ul>
      {sessions.map(s => <li key={s.id}>{s.title}</li>)}
    </ul>
  )
}
```

**Test the Client Component:**
```typescript
// __tests__/components/SessionList.test.tsx
import { SessionList } from '@/components/SessionList'

test('renders sessions', () => {
  const sessions = [
    { id: '1', title: 'Session 1' },
    { id: '2', title: 'Session 2' },
  ]
  render(<SessionList sessions={sessions} />)
  expect(screen.getByText('Session 1')).toBeInTheDocument()
})
```

**Test the data fetching:**
```typescript
// __tests__/lib/sessions.test.ts
import { getSessions } from '@/lib/sessions'

test('fetches sessions from database', async () => {
  const sessions = await getSessions()
  expect(sessions).toHaveLength(2)
})
```

#### 4.2.2 API Routes (App Router)

**Next.js 16 API route structure:**
```typescript
// app/api/sessions/route.ts
import { NextRequest, NextResponse } from 'next/server'

export async function GET(request: NextRequest) {
  const sessions = await prisma.session.findMany()
  return NextResponse.json({ sessions })
}

export async function POST(request: NextRequest) {
  const body = await request.json()
  const session = await prisma.session.create({ data: body })
  return NextResponse.json(session, { status: 201 })
}
```

**Testing API routes:**
```typescript
// __tests__/api/sessions.test.ts
/**
 * @jest-environment node
 */

import { GET, POST } from '@/app/api/sessions/route'
import { NextRequest } from 'next/server'

describe('GET /api/sessions', () => {
  test('returns sessions list', async () => {
    const request = new NextRequest('http://localhost:3001/api/sessions')
    const response = await GET(request)
    const data = await response.json()

    expect(response.status).toBe(200)
    expect(data).toHaveProperty('sessions')
  })
})

describe('POST /api/sessions', () => {
  test('creates new session', async () => {
    const body = { title: 'New Session' }
    const request = new NextRequest('http://localhost:3001/api/sessions', {
      method: 'POST',
      body: JSON.stringify(body),
    })

    const response = await POST(request)
    const data = await response.json()

    expect(response.status).toBe(201)
    expect(data.title).toBe('New Session')
  })
})
```

#### 4.2.3 Dynamic Routes with Params

**Next.js 16 breaking change:**
```typescript
// app/api/sessions/[id]/route.ts
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> } // ← Promise in Next.js 16!
) {
  const { id } = await params // Must await
  const session = await prisma.session.findUnique({ where: { id } })
  return NextResponse.json(session)
}
```

**Testing with async params:**
```typescript
import { GET } from '@/app/api/sessions/[id]/route'

test('fetches session by ID', async () => {
  const request = new NextRequest('http://localhost:3001/api/sessions/123')
  const params = Promise.resolve({ id: '123' }) // Mock params as Promise

  const response = await GET(request, { params })
  const data = await response.json()

  expect(data.id).toBe('123')
})
```

### 4.3 Environment Variables in Tests

**Loading .env files:**
```javascript
// next/jest automatically loads:
.env.local
.env.test.local
.env.test
.env
```

**Priority (highest to lowest):**
1. `process.env` (system variables)
2. `.env.test.local` (gitignored, local test overrides)
3. `.env.test` (committed, shared test config)
4. `.env.local` (gitignored, local dev config)
5. `.env` (committed, defaults)

**Example .env.test:**
```bash
# .env.test (committed)
DATABASE_URL="file:./test.db"
NEXTAUTH_SECRET="test-secret-min-32-chars-long"
ANTHROPIC_API_KEY="test-api-key"
NODE_ENV="test"
```

**Overriding in tests:**
```typescript
const originalEnv = process.env.DATABASE_URL

beforeAll(() => {
  process.env.DATABASE_URL = 'file:./custom-test.db'
})

afterAll(() => {
  process.env.DATABASE_URL = originalEnv
})
```

---

## 5. Coverage & Reporting

### 5.1 Coverage Thresholds

**Bloom's thresholds (jest.config.cjs):**
```javascript
coverageThreshold: {
  global: {
    branches: 70,
    functions: 70,
    lines: 80,
    statements: 80,
  },
}
```

**What they mean:**
- **Lines:** 80% of code lines must be executed
- **Statements:** 80% of statements must run
- **Branches:** 70% of if/else branches must be covered
- **Functions:** 70% of functions must be called

**Per-directory thresholds:**
```javascript
coverageThreshold: {
  global: {
    lines: 80,
  },
  './lib/roi/': {
    lines: 90,      // Higher threshold for critical ROI logic
    functions: 90,
  },
  './components/ui/': {
    lines: 60,      // Lower threshold for UI components
  },
}
```

### 5.2 Running Coverage Reports

**Generate coverage:**
```bash
npm run test:coverage
```

**Output:**
```
--------------------------|---------|----------|---------|---------|
File                      | % Stmts | % Branch | % Funcs | % Lines |
--------------------------|---------|----------|---------|---------|
All files                 |   82.45 |    74.12 |   78.93 |   83.21 |
 lib/roi                  |   91.23 |    85.71 |   90.00 |   92.15 |
  calculator.ts           |   95.00 |    88.23 |   92.30 |   96.15 |
  sensitivityAnalysis.ts  |   87.50 |    83.33 |   87.50 |   88.23 |
 components/bloom         |   78.45 |    68.75 |   75.00 |   79.12 |
  ChatInterface.tsx       |   82.35 |    71.42 |   80.00 |   83.33 |
--------------------------|---------|----------|---------|---------|
```

**Coverage reports generated:**
```
coverage/
├── lcov.info           # LCOV format (for CI tools)
├── lcov-report/        # HTML report (open in browser)
│   └── index.html
├── clover.xml          # Clover format
└── coverage-final.json # JSON format
```

**View HTML report:**
```bash
npm run test:coverage
open coverage/lcov-report/index.html  # macOS
xdg-open coverage/lcov-report/index.html  # Linux
```

### 5.3 Understanding Coverage Gaps

**Uncovered lines example:**
```typescript
// lib/roi/calculator.ts
export function calculateROI(data: ROIData): ROIResult {
  if (!data.initialCost) {
    throw new Error('Initial cost required') // ← NOT COVERED (branch not tested)
  }

  const roi = (data.revenue - data.initialCost) / data.initialCost
  return { roi, npv: calculateNPV(data) }
}
```

**Coverage report highlights:**
```
lib/roi/calculator.ts
  Line 3: throw new Error('Initial cost required')  // ✗ Not covered
```

**Fix with test:**
```typescript
test('throws error when initial cost missing', () => {
  expect(() => calculateROI({ initialCost: 0 })).toThrow('Initial cost required')
})
```

### 5.4 Coverage in CI/CD

**GitHub Actions workflow (.github/workflows/ci-cd.yml):**
```yaml
- name: Run unit tests
  run: npm run test:unit
  env:
    DATABASE_URL: file:./test.db

- name: Upload coverage
  uses: codecov/codecov-action@v3
  if: always()
  with:
    files: ./coverage/lcov.info
    flags: unittests
  continue-on-error: true
```

**Codecov integration:**
- Uploads `lcov.info` to Codecov service
- Provides PR comments with coverage diffs
- Tracks coverage trends over time

**Bloom's CI workflow:**
1. `npm ci` - Install dependencies
2. `npm run test:unit` - Run Jest with coverage
3. Upload coverage to Codecov
4. Fail build if coverage < thresholds

### 5.5 Excluding Code from Coverage

**Ignore comments:**
```typescript
/* istanbul ignore next */
if (process.env.NODE_ENV === 'development') {
  console.log('Debug info')
}

export function internalHelper() {
  /* istanbul ignore next */
  return 'This function is not covered'
}
```

**Exclude in config:**
```javascript
// jest.config.cjs
collectCoverageFrom: [
  'lib/**/*.{ts,tsx}',
  '!lib/utils/debug.ts',        // Exclude debug utilities
  '!lib/**/types.ts',           // Exclude type definitions
  '!lib/**/*.config.ts',        // Exclude config files
]
```

---

## 6. CI/CD Integration

### 6.1 GitHub Actions Workflow

**Bloom's CI/CD pipeline (.github/workflows/ci-cd.yml):**

```yaml
# Code Quality Checks
quality:
  name: Code Quality
  runs-on: ubuntu-latest
  steps:
    - uses: actions/checkout@v4
    - uses: actions/setup-node@v4
      with:
        node-version: 20
        cache: 'npm'
    - run: npm ci
    - run: npm run lint
    - run: npm run type-check

# Unit Tests
test-unit:
  name: Unit Tests
  runs-on: ubuntu-latest
  steps:
    - uses: actions/checkout@v4
    - uses: actions/setup-node@v4
      with:
        node-version: 20
        cache: 'npm'
    - run: npm ci
    - run: npm run test:unit
      env:
        DATABASE_URL: file:./test.db
    - uses: codecov/codecov-action@v3
      if: always()
      with:
        files: ./coverage/lcov.info

# Build
build:
  name: Build Application
  runs-on: ubuntu-latest
  needs: [quality, test-unit]
  steps:
    - uses: actions/checkout@v4
    - uses: actions/setup-node@v4
    - run: npm ci
    - run: npm run build
```

### 6.2 Test Scripts in package.json

**Bloom's test commands:**
```json
{
  "scripts": {
    "test": "jest",
    "test:unit": "jest --testPathPattern=__tests__/lib",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage",
  }
}
```

**Usage:**
- `npm test` - Run all Jest tests once
- `npm run test:unit` - Run only unit tests (lib/)
- `npm run test:watch` - Watch mode for development
- `npm run test:coverage` - Generate coverage report

### 6.3 Parallel Test Execution

**Enable parallel runs:**
```javascript
// jest.config.cjs
module.exports = {
  maxWorkers: '50%', // Use 50% of CPU cores
}
```

**Override in CI:**
```yaml
- run: npm run test:unit -- --maxWorkers=2
```

**Bloom's approach:**
- Local: Use default (auto-detects cores)
- CI: Use 2 workers (GitHub Actions has limited resources)

### 6.4 Caching in CI

**GitHub Actions caching:**
```yaml
- uses: actions/setup-node@v4
  with:
    node-version: 20
    cache: 'npm'  # ← Caches node_modules based on package-lock.json
```

**Benefits:**
- Faster `npm ci` (downloads cached dependencies)
- Reduces build time from ~2min to ~30sec

### 6.5 Handling Flaky Tests

**Retry failed tests:**
```bash
npm test -- --testFailureExitCode=0  # Don't fail on test failures
npm test -- --onlyFailures           # Rerun only failed tests
```

**Jest retry plugin:**
```javascript
// jest.config.cjs
module.exports = {
  testRetries: 2, // Retry failed tests twice
}
```

**Bloom's policy:**
- No retries in CI (flaky tests must be fixed)
- Use `--testRetries=2` locally for debugging

---

## 7. Development Workflow & Debugging

### 7.1 Watch Mode

**Start watch mode:**
```bash
npm run test:watch
```

**Features:**
- Reruns tests on file changes
- Interactive menu for filtering tests
- Press `a` to run all tests
- Press `f` to run only failed tests
- Press `p` to filter by filename
- Press `t` to filter by test name

**Example session:**
```
Watch Usage
 › Press a to run all tests.
 › Press f to run only failed tests.
 › Press p to filter by a filename regex pattern.
 › Press t to filter by a test name regex pattern.
 › Press q to quit watch mode.
 › Press Enter to trigger a test run.
```

### 7.2 Running Specific Tests

**By file pattern:**
```bash
npm test -- calculator
# Runs: __tests__/lib/roi/calculator.test.ts
```

**By test name:**
```bash
npm test -- -t "calculates NPV"
# Runs only tests with "calculates NPV" in the name
```

**By directory:**
```bash
npm run test:unit -- __tests__/lib/roi
# Runs all tests in __tests__/lib/roi/
```

**Skip tests:**
```typescript
test.skip('not implemented yet', () => {
  // This test won't run
})

describe.skip('entire suite skipped', () => {
  test('test 1', () => {})
  test('test 2', () => {})
})
```

**Run only specific tests:**
```typescript
test.only('run this test', () => {
  // Only this test runs
})
```

### 7.3 Debugging Tests

#### 7.3.1 Node.js Debugger

**Add debugger statement:**
```typescript
test('calculates ROI', () => {
  debugger // ← Execution pauses here
  const result = calculateROI(data)
  expect(result.roi).toBe(0.5)
})
```

**Run with debugger:**
```bash
node --inspect-brk node_modules/.bin/jest --runInBand
```

**Then open Chrome:**
```
chrome://inspect
```

#### 7.3.2 VS Code Debugging

**Create .vscode/launch.json:**
```json
{
  "version": "0.2.0",
  "configurations": [
    {
      "type": "node",
      "request": "launch",
      "name": "Jest: Current File",
      "program": "${workspaceFolder}/node_modules/.bin/jest",
      "args": [
        "${fileBasenameNoExtension}",
        "--runInBand",
        "--no-cache"
      ],
      "console": "integratedTerminal",
      "internalConsoleOptions": "neverOpen"
    },
    {
      "type": "node",
      "request": "launch",
      "name": "Jest: All Tests",
      "program": "${workspaceFolder}/node_modules/.bin/jest",
      "args": ["--runInBand", "--no-cache"],
      "console": "integratedTerminal"
    }
  ]
}
```

**Usage:**
1. Open test file
2. Set breakpoints (click left of line numbers)
3. Press F5 or click "Run and Debug"
4. Test pauses at breakpoints

#### 7.3.3 Verbose Output

**Show all test output:**
```bash
npm test -- --verbose
```

**Output:**
```
PASS __tests__/lib/roi/calculator.test.ts
  calculateROI
    ✓ calculates ROI with valid data (2 ms)
    ✓ throws error on invalid input (1 ms)
  calculateNPV
    ✓ calculates NPV with discount rate (3 ms)
```

### 7.4 Performance Profiling

**Slow test detection:**
```bash
npm test -- --testTimeout=1000
# Fails tests that take > 1 second
```

**Log test durations:**
```bash
npm test -- --verbose | grep ms
# Lists execution time for each test
```

**Identify slow tests:**
```typescript
beforeAll(() => {
  console.time('test-setup')
  // ... setup
  console.timeEnd('test-setup')
})

test('complex operation', () => {
  console.time('operation')
  doComplexThing()
  console.timeEnd('operation')
})
```

### 7.5 Common Issues & Solutions

#### Issue 1: "Cannot find module '@/...'"

**Cause:** Path aliases not resolved

**Fix:**
```javascript
// jest.config.cjs
moduleNameMapper: {
  '^@/(.*)$': '<rootDir>/$1',
}
```

#### Issue 2: "SyntaxError: Unexpected token 'export'"

**Cause:** ESM module not transformed

**Fix:**
```javascript
// jest.config.cjs
transformIgnorePatterns: [
  'node_modules/(?!(problematic-package)/)',
]
```

#### Issue 3: "ReferenceError: fetch is not defined"

**Cause:** Node.js < 18 doesn't have native fetch

**Fix:**
```javascript
// jest.setup.js
if (!global.fetch) {
  const nodeFetch = require('node-fetch')
  global.fetch = nodeFetch
}
```

#### Issue 4: Tests hang/don't exit

**Cause:** Open database connections, timers, or event listeners

**Fix:**
```typescript
afterAll(async () => {
  await prisma.$disconnect()
  jest.clearAllTimers()
})
```

#### Issue 5: "useRouter called outside of context"

**Cause:** Next.js hooks need mocking

**Fix:** Add mocks in jest.setup.js (see Section 3.2.2)

---

## Summary

### Key Takeaways

1. **Use next/jest preset** - Simplifies configuration for Next.js 16
2. **Mock Next.js APIs** - Router, navigation, Image component in jest.setup.js
3. **Separate test types** - Jest for unit tests (.test.ts), Playwright for E2E (.spec.ts)
4. **Enforce coverage thresholds** - 80% lines, 70% branches (Bloom's standards)
5. **Integrate with CI/CD** - GitHub Actions runs tests on every push/PR
6. **Use watch mode** - Faster feedback during development
7. **Debug with VS Code** - Set breakpoints, inspect variables

### Bloom-Specific Configuration Highlights

- **Config File:** `jest.config.cjs` (CommonJS for Node.js compatibility)
- **Setup File:** `jest.setup.js` (global mocks, polyfills)
- **Test Pattern:** `*.test.ts` (Jest), `*.spec.ts` (Playwright)
- **Coverage Threshold:** 80% lines, 70% branches
- **CI Integration:** GitHub Actions with Codecov
- **Prisma Mocking:** Database client mocked by default

### Related Documentation

- [01-FUNDAMENTALS.md](01-FUNDAMENTALS.md) - Jest basics and core concepts
- [05-REACT-TESTING.md](05-REACT-TESTING.md) - React Testing Library patterns
- [06-API-TESTING.md](06-API-TESTING.md) - API route testing
- [Playwright KB](../../playwright/) - E2E testing with Playwright

---

**Next Steps:**
1. Review [06-API-TESTING.md](06-API-TESTING.md) for API route testing patterns
2. Explore [05-REACT-TESTING.md](05-REACT-TESTING.md) for component testing best practices
3. Check GitHub Actions logs for CI/CD test results
4. Monitor coverage reports in `coverage/lcov-report/index.html`

**Questions or issues?** See [Troubleshooting](../../ARCHITECTURE.md#troubleshooting) in main architecture docs.
